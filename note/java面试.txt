比较好的 面试教程:
https://www.sxt.cn/2019_Interview_questions/013-13.html
http://how2j.cn/k/j2se-interview/j2se-interview-java/624.html

在这个网站,把集合等内容好好补习一下
http://how2j.cn/k/collection/collection-hashcode/371.html#nowhere


java 面试:
HashMap是非线程安全的，HashTable是线程安全的
执行效率: HashMap > HashTable (因为 HashMap 非线程安全)

HashMap允许设置null , 异步处理
HashTable不允许设置为null , 同步处理


private：  修饰的成员只能在同类中被访问,          而同包,子类和其他包中都不能被访问
public：   在同类、同包、子类（继承自本类）、其他包都可以访问
protected：在同类、同包、子类中可以访问，       其他包中不能被访问

queals()：用于确认两个对象是否相等；补充，哈希值相同的对象不一定equals()，但equals()的两个对象，hash值一定相等

java中是没有指针的，只存在值传递

java中的sleep和wait:
sleep : 线程睡眠,让出系统cpu资源,不影响其他线程的执行
wait :  线程等待,但是继续占用系统资源,直到线程等待结束


因为spring boot版本问题导致的！！现在用的比较新的版本在2.0以上！
server.servlet.context-path=/helloboot  应该这么写


声明抽象方法不可写出大括号


 public void aaa(){
        static int iii = 0;    //  static不可以修饰方法里面的变量 , 只可以修饰类里面的
    }


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************
        Integer f1 = 100, 
        		f2 = 100, 
        		f3 = 150, 
        		f4 = 150;
        
        System.out.println(f1 == f2);   // true
        System.out.println(f3 == f4);   // false
        
        /*
        如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，
        而是直接引用常量池中的Integer对象，
        所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。
         */

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

		int[] arr = {1,2,3,4,5};
		String ssString = "gsedtfheasdrhtaedrtg";
    	System.out.println(ssString.length());		// String 有length()方法
		System.out.println(arr.length);             // 数组没有length()方法，有length 的属性

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

线程:
两种方式:
1,继承Thread类      (因为单继承的局限性,不推荐使用)
2,实现Runnable接口  (推荐使用)

在java中,少用继承(Thread),多用实现(Runnable),
因为,在java中,有单继承的局限性,
假设你现在一段代码,继承了Thread类,就不能继承其他父类了,那就麻烦了~~
所以,在java中,少用继承(Thread),多用实现(Runnable接口)

Thread中的Run方法和start方法的区别:
Run方法只是普通方法调用,属于单线程运行程序
start方法 才是线程的正确启动方式,开启一个新的线程,不保证立即运行,由CPU调用

匿名对象: java中,如果一个对象只使用一次,可以使用匿名对象!
举个例子:
Student stu1 = new Student();
可以简写成:  new Student();

线程中怎么使用匿名: new Thread(new StartRun()).start();

Web12306 wb = new Web12306();   //  线程对象
new Thread(wb , "线程1").start();  // 给线程取个名字
new Thread(wb , "线程2").start();
new Thread(wb , "线程3").start();

//   获取这个线程的名字
System.out.println(Thread.currentThread().getName());   

线程方法:
sleep():让线程停止运行一段时间,处于阻塞状态,单位是时间(毫秒),sleep不会释放锁,抱着资源睡觉
join():阻塞指定的线程,等到另一个线程完成以后,再继续执行(可以理解为插队,让另一个线程优先执行)
yield():暂停当前线程,不是阻塞线程,而是将线程转入就绪状态,如果没有其他需要执行的线程,那么该线程就会马上执行(礼让)
stop():强行停止线程(不推荐使用)
setPoiroty(): 设置优先级, 0-10, 默认是5 , 优先级并不代表绝对的先后顺序,只是调整概率

线程阻塞哪几种情况:
sleep();
join();
wait();

sleep() 和 yield() 
sleep()是阻塞
yield()非阻塞


sleep()会自动唤醒(时间到了之后)
wait()需要自己手工调用notify()方法来唤醒

守护线程: 当被守护的线程执行完毕之后,守护线程也就会关闭

启动线程用 start()方法, 不是 Run()方法

这个教程还算可以
https://www.bilibili.com/video/av30023103/?p=199


静态代理:
https://www.bilibili.com/video/av30023103/?p=201



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

try  catch 里面try加入return
finally语句还是会执行,永远会被执行

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

时间复杂度和空间复杂度不可能同时解决

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

线程的生命周期:
1_新建状态 -> 2_就绪状态 -> 3_运行状态 -> 4_阻塞状态 -> 5_死亡状态


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

static 关键字:
1,随着类的加载而加载
2,被类的所有对象共享
3,如果某个成员变量被所有对象共享,那它应该被定义成静态的
4,可以通过类名.成员变量直接调用  Persion.name="jack"; 不用创建对象
5,静态元素只加载一次(只存在一份)

静态的成员方法不能访问非静态成员变量

静态方法没有this关键字,因为静态是随着类的加载而加载,this是随着对象的创建而存在

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

int占几个字节? 4个字节,32位
boolearn 1位 (true false)

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

为什么要有装箱和拆箱(Integer和int)??
因为java是一个面向对象的编程语言,而基本的数据类型,不具备面向对象的特性.基本数据类型不可以设置为null
举个例子:
Integer III = null;     不会报错    Integer类型可以为null
int iii = null;         报错,       int类型不能为null

假如,现在有个person类,用Integer直接判断是否为null; 但是int类型却不可以
Integer:包装类
int:基本数据类型


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


关于垃圾回收:
将无用的对象进行释放


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


Error 和 Exception 区别:
Error : jvm系统出错
Exception : 属于程序异常,可以用try...catch...捕获异常

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

fina : 定义常量, 方法, 类,声明的方法不能被覆写,声明的类不能被继承
finally: 异常的统一出口
finalaze:垃圾回收的收尾工作


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

assert???
java的一个关键字,开发中用的比较少

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

String sss = new String("AAA");
产生了两个实例化对象,一个是匿名对象"AAA",另一个是new实例化的

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

java没有goto这个关键字,属于保留关键字

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************
1, 重载 : 
        特点:
        方法名相同
        方法的参数类型，参数个不一样
        方法的返回类型 , 方法的修饰符 , 可以不相同
        *main 方法也可以被重载
        
        构造方法可以被重载，但是构造方法不能被重写，子类也不能继承到父类的构造方法

如下所示:
    public static void AAA(){
        System.out.println("不传参数的时候,调用这个方法");
    }
    public static void AAA(int aaa){
        System.out.println("int aaa...........");
    }


2, 重写(又名覆写)
在继承的关系中,子类定义了和父类重名的方法,参数类型或者个数最好一样

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

set你的元素不能重复,那怎么区分是否重复呢??  用==还是 equals()?
答:用 equals() 进行比较,而==比较的是引用的地址,equals()比较的是内容

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


// 一个类只能继承一个抽象类,但是可以实现多个接口
抽象类:
    1,是个类,
    2,由抽象方法,常量,变量,构造方法,普通方法组成
    3,使用 abstract声明
    4,子类要通过 extends继承抽象类,子类如果不是抽象类,必须要覆写抽象类的全部抽象方法
    5,单继承,一个子类只能继承一个抽象类
    6,抽象类可以实现若干个接口
    6,抽象方法不能有方法体，即没有{}

    abstract不能修饰字段。既然是抽象方法，当然是没有实现的方法，根本就没有body部分

接口:
    1,使用 interface声明
    2,子类通过 implements实现接口,子类如果不是抽象类,必须要覆写抽象类的全部抽象方法
    3,不存在单继承局限,一个子类可以实现多个接口
    4,接口不能继承一个抽象类
    5,接口中所有的方法默认都是abstract的，所以接口可以使用abstract修饰，但通常 abstract 可以省略不写
    6,能够修饰interface的只有public、abstract以及默认的三种修饰符

abstract class Aaa{
    public void test(){
        System.out.println("Aaa.test");
    }
    public abstract void test2();
}
interface Bbb{
    public void test();
    public abstract void test2();
}

抽象类可以有方法体,也可以没有方法体
接口不能有方法体


// 实际开发中,接口使用频率 > 抽象类使用频率


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

设计模式:
    单例模式:
        特点:
            1,构造方法私有化


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

char 类型可以存放一个汉字

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

java两大数据类型:
1,基本数据类型
2,引用数据类型

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

三元运算符:
		boolean bb =  (1+1==2)?true:false;
		System.out.println(bb);


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

 String s1 = "QQ";
 String s2 = new String("QQ");

 System.out.println(s1 == s2);       // 返回 false
 System.out.println(s1.equals(s2));  // 返回 true       


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

实现字符串的反转:
        String s1 = "123-QWQ";
        StringBuffer stringBuffer = new StringBuffer(s1);
        System.out.println(stringBuffer.reverse().toString());


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

        Object[] arr = new Object[10];
        for (Object O : arr){
            System.out.println(O);
        }

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

遍历二维数组:
        for (String[] sss : s){
           for (String ssss : sss){
               System.out.println(ssss);
           }
        }

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

集合 迭代器 Iterator 以及 排序:
      List list=new ArrayList();
        list.add(1);
        list.add(6);
        list.add(3);

        System.out.println(list);
        Collections.sort(list);
        System.out.println(list);

        Iterator it =list.iterator();
        while (it.hasNext()){
            System.out.println(it.next());
        }

//       第二种遍历方式
        for (Object i : list){
            System.out.println(i);
        }


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************
java通过反射 拿到对象的属性:

package aaaaaaaa;
import java.lang.reflect.Field;
public class threadTest {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {

        Aaa aaaaa = new Aaa("Tom");
        Class clazz = aaaaa.getClass();
        Field ff = clazz.getDeclaredField("name");
        System.out.println(ff.isAccessible());

        ff.setAccessible(true);
        Object obj = ff.get(aaaaa);
        System.out.println(obj);
    }
}

class Aaa{
    private String name;
    public Aaa(String name) {
        this.name = name;
    }
    public String toString() {
        return "Aaa => [name=" + name + "]";
    }
}



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

链接数据库
        Class.forName("ccom.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection("url" , "username" , "password");
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery("sql");
        rs.next();

        rs.close();
        stmt.close();
        conn.close();

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

sql操作 事务 回滚
     Class.forName("ccom.mysql.jdbc.Driver");
        Connection conn = null;
        Statement stmt = null;

        try {
            conn  = DriverManager.getConnection("url" , "username" , "password");
            conn.setAutoCommit(false);  // 关闭自动提交
            stmt = conn.createStatement();
            stmt.executeUpdate("update user set name='123' where id=001");
            stmt.executeUpdate("update user set name='321' where id=002");
            conn.commit();    // 手动提交

        }catch (RuntimeException e){
            e.printStackTrace();
            if (conn != null){
                conn.rollback();   // 事务 回滚
            }
        }
        final{
            if (stmt != null){
                stmt.close();
            }
            if (conn != null){
                conn.close();
            }
        }

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

servlet 生命周期:
加载 -> 初始化 -> 提供服务 -> 销毁


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


如下四种情况时最容易造成内存泄露的场景，请大家开发时一定注意:
1> 创建大量无用对象
　　比如，我们在需要大量拼接字符串时，使用了String而不是StringBuilder
String str = "";
for (int i = 0; i < 10000; i++) {   
    str += i;     //相当于产生了10000个String对象
}


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

单例设计模式:
这个视频讲解的非常好
https://www.bilibili.com/video/av43222645/?p=33

1,私有的构造方法
2,私有的静态的当前类对象作为属性
3,公有的静态的方法返回当前类对象

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

final 修饰的值不可以被改变,不可以被重写,保证变量安全


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

class Teacher{
    public String name;

    // 成员内部类
    //      将一个类直接定义在类里面,作为成员,与属性或方法层一致
    //      可以和正常类一样,使用不同的修饰符来修饰
    //      可以访问外部类的所有成员,包括私有的
    //      调用 Teacher.Student sd = new Teacher().new Student();
    public class Student{
        public void aaa(){ // 内部类 的 方法
            System.out.println(Teacher.this.name);
        }
    }

    public void metherd(){
        //    局部内部类  第一种写法: 写在普通方法里面
        class clazz{
        }
    }

    {
        //    局部内部类 第二种写法: 写在静态static里面
        class clazz{
        }
    }

    public Teacher{
        //    局部内部类 第三种写法: 写在构造方法里面
        class clazz{
        }
    }
}


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

char不能使用双引号""  必须使用单引号''
        char ccc = '0'; 
        char bbb = "0";  //  编译报错

byte类型的数据,最大是127
        byte bb = 128;   // 报错

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件(.class文件)


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


什么是JVM? 什么是JDK? 什么是JRE?
简单来讲:
    JDK包含JRE，而JRE包含JVM

JDK,JRE,JVM三者关系概括如下:
        jdk是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE。
        JRE是JAVA程序运行时需要的运行环境，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了。
        JDk、JRE内部都包含JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。
    

JVM :
    JVM是Java Virtual Machine（Java虚拟机）的缩写，它是整个java实现跨平台的最核心的部分，
    所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，
    也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，
    由虚拟机将程序解释给本地系统执行。JVM是Java平台的基础，和实际的机器一样，它也有自己的指令集，
    并且在运行时操作不同的内存区域。 JVM通过抽象操作系统和CPU结构，提供了一种与平台无关的代码执行方法，
    即与特殊的实现方法、主机硬件、主机操作系统无关。
    JVM的主要工作是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰
    JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件（.class文件）

JRE: 
    JRE是java runtime environment（java运行环境）的缩写。光有JVM还不能让class文件执行，
    因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到jre目录，
    里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，
    而jvm和lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，
    这样你的朋友就可以运行你写程序了（jre里有运行.class的java.exe）。JRE是Sun公司发布的一个更大的系统，
    它里面就有一个JVM。JRE就与具体的CPU结构和操作系统有关，
    是运行Java程序必不可少的（除非用其他一些编译环境编译成.exe可执行文件……），JRE的地位就象一台PC机一样，
    我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行

JDK:
    JDK是java development kit（java开发工具包）的缩写。每个学java的人都会先在机器上装一个JDK，
    那让我们看一下JDK的安装目录。在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。
    其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、jre。现在我们可以看出这样一个关系，
    JDK包含JRE，而JRE包含JVM
                bin: 最主要的是编译器(javac.exe)
                include: java和JVM交互用的头文件
                lib：类库
                jre: java运行环境
（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）
    总的来说JDK是用于java程序的开发,而jre则是只能运行class而没有编译的功能。eclipse、idea等其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你选jre路径就ok了





*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

8种基本数据类型及其字节数  Java中的原生类（即基本数据类型）有8种，但不包括数组
整数型:      byte    (1字节)        4种
            short   (2字节)
            int     (4字节)
            long    (8字节)

浮点型:     float    (4字节)        2种
            double  (8字节)

布尔型:     boolean  (1位)          1种
字符型:     char     (2字节)        2种

PS:
        1：“字节”是byte，“位”是bit
        1 byte = 8 bit
        1 字节 = 8 位

        char 在Java中是2个字节。java采用 unicode ，2个字节（16位）来表示一个字符。
        short 2个字节
        int 4个字节
        long 8个字节 (64位)

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

&和&&的区别(不同点):
        对于&：无论任何情况，&两边的操作数或表达式都会参与计算
        对于&&：当&&左边的操作数为false或左边表达式结果为false时，&&右边的操作数或表达式将不参与计算，此时最终结果都为false。
        ** 推介平时多使用&&，因为它效率更高些

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

位运算符“<<”, 是将一个数左移n位，就相当于乘以了2的n次方，
那么，一个数乘以8只要将其左移3位即可，位运算cpu直接支持的，效率最高。
所以，2乘以8等于几的最效率的方法是2 << 3

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

break和continue的作用 区别
        break: 结束当前循环并退出当前循环体。
        break还可以退出switch语句
        continue: 循环体中后续的语句不执行，但是循环没有结束，继续进行循环条件的判断（for循环还会i++）。
                  continue只是结束本次循环。


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

递归算法解题通常显得很简洁，但运行效率较低。所以一般不提倡用递归算法设计程序

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

数组的长度是固定的，一经定义，不能再发生变化（数组的扩容）


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

this和super区别:

this是对象内部指代自身的引用,同时也是解决成员变量和局部变量同名问题；this可以调用成员变量，不能调用局部变量

super代表对当前对象的直接父类对象的引用，
super可以调用直接父类的成员变量
super可以调用直接父类的成员方法

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

static变量是属于整个类的，也称为类变量
 类名.变量名 直接调用

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

final和abstract 区别
abstract可以用来修饰类和方法，(不能用来修饰属性和构造方法)
抽象类:使用abstract修饰的类是抽象类，需要被继承，
抽象方法:使用abstract修饰的方法是抽象方法，需要子类被重写

final可以用来修饰类、方法和属性，不能修饰构造方法。
使用final修饰的类不能被继承，使用final修饰的方法不能被重写，
使用final修饰的变量的值不能被修改，所以就成了常量。

特别注意：final修饰基本类型变量，其值不能改变，由原来的变量变为常量；
但是final修饰引用类型变量，
栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。例如:
 
class Test {
    public static void main(String[] args) {
        final Dog dog = new Dog("欧欧");
        dog.name = "美美";//正确
        dog = new Dog("亚亚");//错误
    }
}



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

写出java.lang.Object类的六个常用方法:
                                1,equals      比较对象的地址值是否相等，如果子类重写，则比较对象的内容是否相等
                                2,hashCode()  获取哈希码
                                3,toString()  把数据转变成字符串
                                4,getClass()  获取类结构信息
                                5,notify()    多线程中唤醒功能
                                6,notifyAll() 多线程中唤醒所有等待线程的功能

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

区别:
public     公共的 可被同一项目中所有的类访问
default    默认的 可被同一个包中的类访问
protected  同一个类,同一个包,子类
private    私有的 只能被这个类本身访问


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应构造方法，而不执行父类无参构造方法
如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

==和equals的区别
“==”使用情况如下：
            a) 基本类型，比较的是值
            b) 引用类型，比较的是地址
            c) 不能比较没有父子关系的两个对象


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

垃圾回收:

public class threadTest {
    public static void main(String[] args) {
        Persion persion = new Persion();
        persion=null;
        System.gc();
    }

}

class Persion{
    public void finalize(){   // 重写垃圾回收的方法
        System.out.println("GC is return............");
    }
}




*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

Integer与int的区别 :
     int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，
     例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer
     在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，
     而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型

    int i1 = null;      // 报错
    Integer i2 = null;  // 不报错

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

 Java是解释型语言，编译出来的是字节码 Java程序经编译后会生产byte code

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

static方法能处理非static的属性 是错误的!!
分析：因为static得方法在装载class得时候首先完成，比构造方法早，此时非static得属性和方法还没有完成初始化所以不能调用

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

面向对象的三大特征：封装、继承、多态

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

如何看见 java.lang.OutOfMemoryError (内存溢出 内存泄漏) ?
在eclipse运行下面这段代码,并且 在eclipse运行参数中, Run Configuration->VM argument设置:-Xmx5m -Xmx5m
        int count = 0;
        List<Object> list = new ArrayList<Object>();
        while(true){
            list.add(new Object());
            System.out.println(++count);
        }

详情见:
https://www.cnblogs.com/xiaoxi/p/7406903.html        
		
	

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

        int aaa = 1;
        int bbb = 1;
        System.out.println(aaa++); // 输出: 1 (先输出,再去+1)
        System.out.println(++bbb); // 输出: 2 (先+1 , 再输出)

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

Java 中byte表示的数值范围是什么?  
答： 范围是-128至127

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



java程序经编译后会产生 byte code (字节码文件)

分析：java程序编译后会生成字节码文件,就是.class文件



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


成员变量用static修饰和不用static修饰有什么区别?

1，两个变量的生命周期不同
        成员变量随着对象的创建而存在，随着对象的被回收而释放
        静态变量随着类的加载而存在，随着类的消失而消失

2，调用方式不同。
        成员变量只能被对象调用。
        静态变量可以被对象调用，还可以被类名调用

        对象调用：p.country
        类名调用 ：Person.country

3，别名不同
        成员变量也称为实例变量
        静态变量称为类变量

4，数据存储位置不同
        成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据.
        静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

如果变量用final修饰，则怎样？如果方法final修饰，则怎样?

1、用final修饰的类不能被扩展，也就是说不可能有子类
3、用final修饰的变量最多只能赋值一次

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

        Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;
        System.out.println(f1 == f2);   // 返回 true
        System.out.println(f3 == f4);   // 返回 false

        咦?? 很奇怪吧?? 如果不明就里很容易认为两个输出要么都是true要么都是false
         
        首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象，所以下面的==运算比较的不是值而是引用

        简单的说，如果字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，
        所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


很多时候我们可能都需要用&&而不是&，
例如在验证用户登录时判定用户名不是null而且不是空字符串，
应当写为：
username != null && !username.equals("")
二者的顺序不能交换，
更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

switch表达式后面的数据类型只能是byte,short，char，int四种整形类型，
枚举类型和java.lang.String类型（从java 7才允许），
不能是boolean类型。

总结: 6种类型: 
            byte,short,char,int四种整形类型  加上: 枚举类型(enum) , String 
            总共6种

在网上看到好多文章，说switch还支持byte,short,char,int 的包装类，
首先可以肯定说switch不支持这些包装类

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同
(2)如果两个对象的hashCode相同，它们并不一定相同

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

在Joshua Bloch的大作《Effective Java》
（很多软件公司，《Effective Java》、《Java编程思想》以及《重构：改善既有代码质量》是Java程序员必看书籍

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

       1. 使用==操作符检查“参数是否为这个对象的引用”
       2. 使用instanceof操作符检查“参数是否为正确的类型”

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

Java 编程语言只有值传递参数

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

抽象的（abstract）方法是否可同时是静态的（static）?
不能,   抽象方法需要子类重写，而静态的方法是无法被重写的

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

静态变量和实例变量的区别？
        答：静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，
        一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；
        实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它，静态变量可以实现让多个对象共享内存

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？    
        答：不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，因此在调用静态方法时可能对象并没有被初始化

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？
        答：可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。 

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

Java 中的final关键字有哪些用法？
答：
        (1)修饰类：表示该类不能被继承
        (2)修饰方法：表示方法不能被重写但是允许重载
        (3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）
        (4)修饰对象：对象的引用地址不能变，但是对象的初始化值可以变

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

Q: 静态方法 和 构造方法谁先执行??

A: 静态方法 永远最先执行,哪怕是子类的静态方法 > 然后才是构造方法

ps:如果是 子类继承父类的话,那么先后顺序应该是(数字代表执行顺序):
父类 静态方法 <1>
子类 静态方法 <2>
父类 构造方法 <3>
子类 构造方法 <4>

------直接上代码:

class Father{
    static{
        System.out.print("父类 静态方法 <1>\n");
    }
    public Father(){
        System.out.print("父类 构造方法 <3>\n");
    }
}
class Son extends Father{
    static{
        System.out.print("子类 静态方法 <2>\n");
    }
    public Son(){
        System.out.print("子类 构造方法 <4>\n");
    }
}

public class A{
    public static void main(String[] args){
        Father BBBBBBBBB = new Son();
        System.out.println("--------------------------");
        BBBBBBBBB = new Son();
    }
}



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

反转字符串:
    public static String reverse(String originStr) {
        if(originStr == null || originStr.length() <= 1){
            return originStr;
        }else {
            return reverse(originStr.substring(1)) + originStr.charAt(0);
        }
    }

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？
        String s1 = "你好";
        try {
            String s2 = new String(s1.getBytes("GB2312"), "ISO-8859-1");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

打印昨天的当前时刻
        Calendar cal = Calendar.getInstance();
        cal.add(Calendar.DATE, -1);
        System.out.println(cal.getTime());

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

面向对象设计原则有哪些
关于反射
String 和StringBuffer的区别
A:
StringBuffer可以改变,String不能...
        StringBuffer stringBuffer = new StringBuffer("AAA");
        stringBuffer.append("111");
        System.out.println(stringBuffer);

        StringBuilder stringBuilder = new StringBuilder("aaa");
        stringBuilder.append("111");
        System.out.println(stringBuilder);

而且,StringBuffer是线程安全的,stringBuilder不是,
按住Ctrl 鼠标移动到 append 方法上面,可以看到有 synchronized :
    public synchronized StringBuffer append(String str) {
        toStringCache = null;
        super.append(str);
        return this;
    }


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

Collection 和 Collections的区别
Collection是接口，是List和Set的父接口
Collections是工具类，提供了排序，混淆等等很多实用方法

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

 位与 
        int i  =5;
        int j = 6;
        System.out.println(Integer.toBinaryString(i)); //5的二进制是101
        System.out.println(Integer.toBinaryString(j)); //6的二进制是110
        System.out.println(i&j); //所以 5&6 对每一位进行与运算，得到 100->4

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式
区别1：
HashMap可以存放 null
Hashtable不能存放null
区别2：
HashMap不是线程安全的类
Hashtable是线程安全的类 

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


Overload和Override的区别，即重载和重写的区别。 Overloaded的方法是否可以改变返回值的类型? 

Overload是方法重载的意思，指的是在同一个类里面，方法名一样，但是参数不一样
Override是方法重写的意思，指的是子类继承了父类的某个方法后，重新又写了一遍

        Overloaded的方法是否可以改变返回值的类型?
可以，重载其实本质上就是完全不同的方法，只是恰好取了相同的名字 

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


    Error和Exception有什么区别?

Error和Exception都实现了Throwable接口
Error指的是JVM层面的错误，比如内存不足OutOfMemoryError
Exception 指的是代码逻辑的异常，比如下标越界OutOfIndexException 

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

heap: 堆
stack: 栈 (在一些书籍里，会被翻译为堆栈，实际上指的就是单纯的这个栈)

存放的内容不一样：
heap: 是存放对象的
stack: 是存放基本类型(int, float, boolean 等等)、引用(对象地址)、方法调用

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


short s1 = 1;
s1 = s1 + 1;  // 报错是因为,右侧的表达式会返回一个Int类型的整数，但是左边却是short来接收,所以就会出现强制转换错误


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


String s = new String("xyz");创建了几个String Object?

String s = new String("xyz");
首先构造方法 new String("xyz"); 中的"xyz" 这本身就是一个字符串对象
然后 new 关键字一定会创建一个对象
所以总共创建了两个String对象 

至于左边的String s , 那叫做引用

PS:
还有一种说法:
String s = new String("xyz");创建了几个String Object?

分为两种情况：
1.如果String常理池中，已经创建"xyz"，则不会继续创建，此时只创建了一个对象new String("xyz");
2.如果String常理池中，没有创建"xyz"，则会创建两个对象，一个对象的值是"xyz"，一个对象new String("xyz")


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

接口是否可继承接口?
    可以，比如List 就继承了接口Collection

抽象类是否可实现(implements)接口?
    可以，比如 MouseAdapter鼠标监听适配器 是一个抽象类，并且实现了MouseListener接口

抽象类是否可继承实体类 ( concrete class ) ?
    可以，所有抽象类，都继承了Object 

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

 abstract的method(方法)是否可同时是static,是否可同时是synchronized?

都不可以 

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


数组有没有length()这个方法? String有没有length()这个方法?
        数组获取长度的手段是 .length 属性
        String获取长度的手段是 length()方法
        集合获取长度的手段是 size()方法
        文件获取长度的手段是 length()方法


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


Set里的元素是不能重复的，那么用什么方法来区分重复与否呢?
    以HashSet为例，判断重复的逻辑是：
    1. 首先看hashcode是否相同，如果不同，就是不重复的
    2. 如果hashcode一样，再比较equals，如果不同，就是不重复的，否则就是重复的


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


构造器Constructor是否可被override?是否可以继承String类?
    子类不能继承父类的构造方法，所以就不存在重写父类的构造方法
    注： super() 表示子类调用父类的构造方法，这不能被叫做继承父类的构造方法
    String是final修饰的，所以不能够被继承 

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


 垃圾回收的优点和原理。并考虑2种回收机制
与C语言开发人员需要手动进行内存资源的释放不同，Java提供垃圾回收机制，自动进行GC，
将开发人员从容易犯错的内存资源管理中解放出来。

原理：当某个一个对象，没有任何引用指向它的时候，那么它就满足垃圾回收的条件，
在适当的时候，JVM虚拟机进行GC将其回收，释放空间，以供后续再利用

两种常见的回收机制：
1. 定时回收
每隔30分钟进行一次回收，这种机制的弊端是如果垃圾产生的比较快，有可能30分钟之内垃圾已经把内存占用光了，导致性能变慢

2. 当垃圾占到某个百分比的时候，进行回收
比如，当垃圾占到70%的时候，进行回收。 这种机制的弊端是，如果垃圾产生的频率很快，那么JVM就必须高频率的进行垃圾回收。 
而在垃圾回收的过程中， JVM会停顿下来，只做垃圾回收，而影响业务功能的正常运行

一般说来 JVM会采用两种机制结合的方式进行垃圾回收

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

你所知道的集合类都有哪些？主要方法？
    常见的集合
         ArrayList, LinkedList, HashSet, HashMap, TreeSet 等等
    常见方法：
         size()
         add()
         remove()

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

解析XML文档有哪几种方式?
    主要是两种，SAX和DOM
    SAX 就是逐行读取，直到找到目标数据为止
    DOM 是先全文档加载，然后读取 


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

一个".java"源文件中是否可以包括多个类（不是内部类）？有什么限制?
    可以包括多个类，但是只能出现一个public修饰的类，但是可以出现多个非public修饰的类

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


Q:java中有几种类型的流?
    Java中所有的流都是基于字节流，所以最基本的流是
    输入输出字节流
        InputStream
        OutputStream
    在字节流的基础上，封装了字符流
        Reader
        Writer
    进一步，又封装了缓存流
        BufferedReader
        PrintWriter
    以及数据流
        DataInputStream
        DataOutputStream
    对象流
        ObjectInputStream
        ObjectOutputStream

以及一些其他的奇奇怪怪的流 ~~~ 


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


静态变量和实例变量的区别?
    静态变量 直接通过类就可以访问，无需实例
    实例变量 比如通过类的某个具体实例，才可以访问 


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

 什么是java序列化，如何实现java序列化?
序列化指的是把一个Java对象，通过某种介质进行传输，比如Socket输入输出流，或者保存在一个文件里
实现java序列化的手段是让该类实现接口 Serializable，这个接口是一个标识性接口，没有任何方法，仅仅用于表示该类可以序列化

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

是否可以从一个static方法内部发出对非static方法的调用?
不行，因为非static方法需要一个具体的实例才可以调用，而调用 static方法的时候，不一定存在一个实例 


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


Q:在JAVA中，如何跳出当前的多重嵌套循环?
public class A {
    public static void main(String[] args) {
        //打印单数
        outloop: //outloop这个标示是可以自定义的比如outloop1,ol2,out5
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                System.out.println(i+":"+j);
                if(j == 5){
                    break outloop; //如果是双数，结束外部循环
                }
            }
        }
    }
}

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


内部类可以引用外部类的成员吗？有没有什么限制?
        可以使用
        如果是非静态内部类，可以使用外部类的所有成员
        如果是静态内部类，只能使用外部类的静态成员


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


sleep() 和 wait() 有什么区别?
    首先sleep和wait之间没有任何关系
    sleep 是Thread类的方法，指的是当前线程暂停
    wait 是Object类的方法， 指的占用当前对象的线程临时释放对当前对象的占用，以使得其他线程有机会占用当前对象。 所以调用wait方法一定是在synchronized 中进行

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

说出数据连接池的工作机制是什么?
    数据库连接池原理：
    因为创建连接和关闭连接的行为是非常耗时的，会显著降低软件的性能表现。
    解决办法就是先创建n条数据库连接Connection，循环使用，但是不进行关闭，这样再执行SQL语句，
    就不需要额外创建连接了，直接使用现成的连接就可以了，从而节约了创建连接和关闭连接的时间开销

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************























































































































Compile:编绎

Run:运行

Class:类

Object:对象

System:系统

System:系统

out:输出

print:打印

line:行

variable:变量

type:类型

static:静态的

array:数组

parameter:参数

method:方法

function:函数

public:公有的

default:默认

get:得到

private:私有的

import:导入

set:设置

package:包

access:访问
atement:表行对象

 

protected:受保护的

 

void:无(返回类型)

 

operation:操作,运算

 

member-variable:成员变量

 

member-function:成员函数

 

extends:继承

 

base

 

class:基类

 

parent

 

class:父类

 

interface:接口

 

child

 

class:子类

 

super

 

class:超类

 

overload:重载

 

abstract:抽象

 

exception:异常

 

implements:实现

 

Runtime:运行时

 

derived

 

class:派生类

 

override:重写,覆盖

 

final:最终的,不能改变的

 

ArrayIndexOutOfBoundsException:数组下标越界异常

 

ArithmeticException:算术异常

 

NullPointerException:空引用(指针)异常

 

ClassNotFoundException:类没有发现异常

 

NumberFormatException:数字格式异常(字符串不能转化为数字)

 

Try:尝试

 

Catch:捕捉

 

Finally:最后

 

Throw:抛出

 

Throws:

 

(投掷)表示强制异常处理

 

Throwable:(可抛出的)表示所有异常类的祖先类

 

Lang:language,语言

 

Random:随机

 

Util:工具

 

Display:显示

 

Collection:集合

 

ArrayList:(数组列表)表示动态数组

 

HashMap:

 

散列表,哈希表

 

Swing:轻巧的

 

Awt:abstract

 

window

 

toolkit:抽象窗口工具包

 

Frame:窗体

 

Size:尺寸

 

Title:标题

 

Add:添加

 

Panel:面板

 

Layout:布局

 

Scroll:滚动

 

Vertical:垂直

 

Horizonatal:水平

 

Label:标签

 

TextField:文本框

 

TextArea:文本域

 

Button:按钮

 

Checkbox:复选框

 

Focus:焦点

 

Event:事件

 

Combobox:复选框

 

Listener:监听

 

Mouse:鼠标

 

Key:键

 

Grid:网格

 

Border:边界

 

Flow:流

 

MenuItem:菜单

 

项

 

MenuBar:菜单栏

 

Menu:菜单

 

Icon:图标

 

Dialog:对话框

 

Message:消息

 

Tree:树

 

Node:节点

 

Radiobutton:单选按钮

 

PopupMenu:弹出菜单

 

Jdbc:java

 

database

connectivity,java

数据库连接
--------------------- 
作者：身轻如阿宝 
来源：CSDN 
原文：https://blog.csdn.net/gt674342815/article/details/77826097 
版权声明：本文为博主原创文章，转载请附上博文链接！