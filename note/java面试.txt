
java 面试:
HashMap是非线程安全的，HashTable是线程安全的
执行效率: HashMap > HashTable (因为 HashMap 非线程安全)

HashMap允许设置null , 异步处理
HashTable不允许设置为null , 同步处理


private：修饰的成员只能在同类中被访问,而同包,子类和其他包中都不能被访问
public：在同类、同包、子类（继承自本类）、其他包都可以访问
protected：在同类、同包、子类中可以访问，其他包中不能被访问

queals()：用于确认两个对象是否相等；补充，哈希值相同的对象不一定equals()，但equals()的两个对象，hash值一定相等

java中是没有指针的，只存在值传递


java中的sleep和wait:
sleep : 线程睡眠,让出系统cpu资源,不影响其他线程的执行
wait :  线程等待,但是继续占用系统资源,直到线程等待结束


因为spring boot版本问题导致的！！现在用的比较新的版本在2.0以上！
server.servlet.context-path=/helloboot  应该这么写


声明抽象方法不可写出大括号


 public void aaa(){
        static int iii = 0;    //  static不可以修饰方法里面的变量 , 只可以修饰类里面的
    }


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************
        Integer f1 = 100, 
        		f2 = 100, 
        		f3 = 150, 
        		f4 = 150;
        
        System.out.println(f1 == f2);   // true
        System.out.println(f3 == f4);   // false
        
        /*
        如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，
        而是直接引用常量池中的Integer对象，
        所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。
         */

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

		int[] arr = {1,2,3,4,5};
		String ssString = "gsedtfheasdrhtaedrtg";
    	System.out.println(ssString.length());		// String 有length()方法
		System.out.println(arr.length);             // 数组没有length()方法，有length 的属性

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

线程:
两种方式:
1,继承Thread类      (因为单继承的局限性,不推荐使用)
2,实现Runnable接口  (推荐使用)

在java中,少用继承(Thread),多用实现(Runnable),
因为,在java中,有单继承的局限性,
假设你现在一段代码,继承了Thread类,就不能继承其他父类了,那就麻烦了~~
所以,在java中,少用继承(Thread),多用实现(Runnable接口)

Thread中的Run方法和start方法的区别:
Run方法只是普通方法调用,属于单线程运行程序
start方法 才是线程的正确启动方式,开启一个新的线程,不保证立即运行,由CPU调用

匿名对象: java中,如果一个对象只使用一次,可以使用匿名对象!
举个例子:
Student stu1 = new Student();
可以简写成:  new Student();

线程中怎么使用匿名: new Thread(new StartRun()).start();

Web12306 wb = new Web12306();   //  线程对象
new Thread(wb , "线程1").start();  // 给线程取个名字
new Thread(wb , "线程2").start();
new Thread(wb , "线程3").start();

//   获取这个线程的名字
System.out.println(Thread.currentThread().getName());   

线程方法:
sleep():让线程停止运行一段时间,处于阻塞状态,单位是时间(毫秒),sleep不会释放锁,抱着资源睡觉
join():阻塞指定的线程,等到另一个线程完成以后,再继续执行(可以理解为插队,让另一个线程优先执行)
yield():暂停当前线程,不是阻塞线程,而是将线程转入就绪状态,如果没有其他需要执行的线程,那么该线程就会马上执行(礼让)
stop():强行停止线程(不推荐使用)
setPoiroty(): 设置优先级, 0-10, 默认是5 , 优先级并不代表绝对的先后顺序,只是调整概率

线程阻塞哪几种情况:
sleep();
join();
wait();

sleep() 和 yield() 
sleep()是阻塞
yield()非阻塞


sleep()会自动唤醒(时间到了之后)
wait()需要自己手工调用notify()方法来唤醒

守护线程: 当被守护的线程执行完毕之后,守护线程也就会关闭

启动线程用 start()方法, 不是 Run()方法

这个教程还算可以
https://www.bilibili.com/video/av30023103/?p=199


静态代理:
https://www.bilibili.com/video/av30023103/?p=201



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

try  catch 里面try加入return
finally语句还是会执行,永远会被执行

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

时间复杂度和空间复杂度不可能同时解决

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

线程的生命周期:
1_新建状态 -> 2_就绪状态 -> 3_运行状态 -> 4_阻塞状态 -> 5_死亡状态


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

static 关键字:
1,随着类的加载而加载
2,被类的所有对象共享
3,如果某个成员变量被所有对象共享,那它应该被定义成静态的
4,可以通过类名.成员变量直接调用  Persion.name="jack";

静态的成员方法不能访问非静态成员变量

静态方法没有this关键字,因为静态是随着类的加载而加载,this是随着对象的创建而存在

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

int占几个字节? 4个字节,32位
boolearn 1位 (true false)

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

为什么要有装箱和拆箱(Integer和int)??
因为java是一个面向对象的编程语言,而基本的数据类型,不具备面向对象的特性.基本数据类型不可以设置为null
举个例子:
Integer III = null;     不会报错    Integer类型可以为null
int iii = null;         报错,       int类型不能为null

假如,现在有个person类,用Integer直接判断是否为null; 但是int类型却不可以
Integer:包装类
int:基本数据类型


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


关于垃圾回收:
将无用的对象进行释放


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


Error 和 Exception 区别:
Error : jvm系统出错
Exception : 属于程序异常,可以用try...catch...捕获异常

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

fina : 定义常量, 方法, 类,声明的方法不能被覆写,声明的类不能被继承
finally: 异常的统一出口
finalaze:垃圾回收的收尾工作


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

assert???
java的一个关键字,开发中用的比较少

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

String sss = new String("AAA");
产生了两个实例化对象,一个是匿名对象"AAA",另一个是new实例化的

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

java没有goto这个关键字,属于保留关键字

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

重载:方法名相同,但是参数的类型或者个数不相同,
如下所示:
    public static void AAA(){
        System.out.println("不传参数的时候,调用这个方法");
    }
    public static void AAA(int aaa){
        System.out.println("int aaa...........");
    }

重写(又名覆写): 在继承的关系中,子类定义了和父类重名的方法,参数类型或者个数最好一样

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

set你的元素不能重复,那怎么区分是否重复呢??  用==还是 equals()?
答:用 equals() 进行比较,而==比较的是引用的地址,equals()比较的是内容

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


// 一个类只能继承一个抽象类,但是可以实现多个接口
抽象类:
    1,是个类,
    2,由抽象方法,常量,变量,构造方法,普通方法组成
    3,使用 abstract声明
    4,子类要通过 extends继承抽象类,子类如果不是抽象类,必须要覆写抽象类的全部抽象方法
    5,单继承,一个子类只能继承一个抽象类
    6,抽象类可以实现若干个接口

接口:
    1,使用 interface声明
    2,子类通过 implements实现接口,子类如果不是抽象类,必须要覆写抽象类的全部抽象方法
    3,不存在单继承局限,一个子类可以实现多个接口
    4,接口不能继承一个抽象类

abstract class Aaa{
    public void test(){
        System.out.println("Aaa.test");
    }
    public abstract void test2();
}
interface Bbb{
    public void test();
    public abstract void test2();
}

抽象类可以有方法体,也可以没有方法体
接口不能有方法体


// 实际开发中,接口使用频率 > 抽象类使用频率


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

设计模式:
    单例模式:
        特点:
            1,构造方法私有化


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

char 类型可以存放一个汉字

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

java两大数据类型:
1,基本数据类型
2,引用数据类型

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

三元运算符:
		boolean bb =  (1+1==2)?true:false;
		System.out.println(bb);


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

 String s1 = "QQ";
 String s2 = new String("QQ");

 System.out.println(s1 == s2);       // 返回 false
 System.out.println(s1.equals(s2));  // 返回 true       


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

实现字符串的反转:
        String s1 = "123-QWQ";
        StringBuffer stringBuffer = new StringBuffer(s1);
        System.out.println(stringBuffer.reverse().toString());


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

        Object[] arr = new Object[10];
        for (Object O : arr){
            System.out.println(O);
        }

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

遍历二维数组:
        for (String[] sss : s){
           for (String ssss : sss){
               System.out.println(ssss);
           }
        }

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

集合 迭代器 Iterator 以及 排序:
      List list=new ArrayList();
        list.add(1);
        list.add(6);
        list.add(3);

        System.out.println(list);
        Collections.sort(list);
        System.out.println(list);

        Iterator it =list.iterator();
        while (it.hasNext()){
            System.out.println(it.next());
        }

//       第二种遍历方式
        for (Object i : list){
            System.out.println(i);
        }


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************
java通过反射 拿到对象的属性:

package aaaaaaaa;
import java.lang.reflect.Field;
public class threadTest {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {

        Aaa aaaaa = new Aaa("Tom");
        Class clazz = aaaaa.getClass();
        Field ff = clazz.getDeclaredField("name");
        System.out.println(ff.isAccessible());

        ff.setAccessible(true);
        Object obj = ff.get(aaaaa);
        System.out.println(obj);
    }
}

class Aaa{
    private String name;
    public Aaa(String name) {
        this.name = name;
    }
    public String toString() {
        return "Aaa => [name=" + name + "]";
    }
}



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

链接数据库
        Class.forName("ccom.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection("url" , "username" , "password");
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery("sql");
        rs.next();

        rs.close();
        stmt.close();
        conn.close();

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

sql操作 事务 回滚
     Class.forName("ccom.mysql.jdbc.Driver");
        Connection conn = null;
        Statement stmt = null;

        try {
            conn  = DriverManager.getConnection("url" , "username" , "password");
            conn.setAutoCommit(false);  // 关闭自动提交
            stmt = conn.createStatement();
            stmt.executeUpdate("update user set name='123' where id=001");
            stmt.executeUpdate("update user set name='321' where id=002");
            conn.commit();    // 手动提交

        }catch (RuntimeException e){
            e.printStackTrace();
            if (conn != null){
                conn.rollback();   // 事务 回滚
            }
        }
        final{
            if (stmt != null){
                stmt.close();
            }
            if (conn != null){
                conn.close();
            }
        }

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

servlet 生命周期:
加载 -> 初始化 -> 提供服务 -> 销毁


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



















































































































Compile:编绎

Run:运行

Class:类

Object:对象

System:系统

System:系统

out:输出

print:打印

line:行

variable:变量

type:类型

static:静态的

array:数组

parameter:参数

method:方法

function:函数

public:公有的

default:默认

get:得到

private:私有的

import:导入

set:设置

package:包

access:访问
atement:表行对象

 

protected:受保护的

 

void:无(返回类型)

 

operation:操作,运算

 

member-variable:成员变量

 

member-function:成员函数

 

extends:继承

 

base

 

class:基类

 

parent

 

class:父类

 

interface:接口

 

child

 

class:子类

 

super

 

class:超类

 

overload:重载

 

abstract:抽象

 

exception:异常

 

implements:实现

 

Runtime:运行时

 

derived

 

class:派生类

 

override:重写,覆盖

 

final:最终的,不能改变的

 

ArrayIndexOutOfBoundsException:数组下标越界异常

 

ArithmeticException:算术异常

 

NullPointerException:空引用(指针)异常

 

ClassNotFoundException:类没有发现异常

 

NumberFormatException:数字格式异常(字符串不能转化为数字)

 

Try:尝试

 

Catch:捕捉

 

Finally:最后

 

Throw:抛出

 

Throws:

 

(投掷)表示强制异常处理

 

Throwable:(可抛出的)表示所有异常类的祖先类

 

Lang:language,语言

 

Random:随机

 

Util:工具

 

Display:显示

 

Collection:集合

 

ArrayList:(数组列表)表示动态数组

 

HashMap:

 

散列表,哈希表

 

Swing:轻巧的

 

Awt:abstract

 

window

 

toolkit:抽象窗口工具包

 

Frame:窗体

 

Size:尺寸

 

Title:标题

 

Add:添加

 

Panel:面板

 

Layout:布局

 

Scroll:滚动

 

Vertical:垂直

 

Horizonatal:水平

 

Label:标签

 

TextField:文本框

 

TextArea:文本域

 

Button:按钮

 

Checkbox:复选框

 

Focus:焦点

 

Event:事件

 

Combobox:复选框

 

Listener:监听

 

Mouse:鼠标

 

Key:键

 

Grid:网格

 

Border:边界

 

Flow:流

 

MenuItem:菜单

 

项

 

MenuBar:菜单栏

 

Menu:菜单

 

Icon:图标

 

Dialog:对话框

 

Message:消息

 

Tree:树

 

Node:节点

 

Radiobutton:单选按钮

 

PopupMenu:弹出菜单

 

Jdbc:java

 

database

connectivity,java

数据库连接
--------------------- 
作者：身轻如阿宝 
来源：CSDN 
原文：https://blog.csdn.net/gt674342815/article/details/77826097 
版权声明：本文为博主原创文章，转载请附上博文链接！