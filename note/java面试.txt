比较好的 面试教程:
https://www.sxt.cn/2019_Interview_questions/013-13.html
http://how2j.cn/k/j2se-interview/j2se-interview-java/624.html


java 面试:
HashMap是非线程安全的，HashTable是线程安全的
执行效率: HashMap > HashTable (因为 HashMap 非线程安全)

HashMap允许设置null , 异步处理
HashTable不允许设置为null , 同步处理


private：修饰的成员只能在同类中被访问,而同包,子类和其他包中都不能被访问
public：在同类、同包、子类（继承自本类）、其他包都可以访问
protected：在同类、同包、子类中可以访问，其他包中不能被访问

queals()：用于确认两个对象是否相等；补充，哈希值相同的对象不一定equals()，但equals()的两个对象，hash值一定相等

java中是没有指针的，只存在值传递


java中的sleep和wait:
sleep : 线程睡眠,让出系统cpu资源,不影响其他线程的执行
wait :  线程等待,但是继续占用系统资源,直到线程等待结束


因为spring boot版本问题导致的！！现在用的比较新的版本在2.0以上！
server.servlet.context-path=/helloboot  应该这么写


声明抽象方法不可写出大括号


 public void aaa(){
        static int iii = 0;    //  static不可以修饰方法里面的变量 , 只可以修饰类里面的
    }


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************
        Integer f1 = 100, 
        		f2 = 100, 
        		f3 = 150, 
        		f4 = 150;
        
        System.out.println(f1 == f2);   // true
        System.out.println(f3 == f4);   // false
        
        /*
        如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，
        而是直接引用常量池中的Integer对象，
        所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。
         */

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

		int[] arr = {1,2,3,4,5};
		String ssString = "gsedtfheasdrhtaedrtg";
    	System.out.println(ssString.length());		// String 有length()方法
		System.out.println(arr.length);             // 数组没有length()方法，有length 的属性

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

线程:
两种方式:
1,继承Thread类      (因为单继承的局限性,不推荐使用)
2,实现Runnable接口  (推荐使用)

在java中,少用继承(Thread),多用实现(Runnable),
因为,在java中,有单继承的局限性,
假设你现在一段代码,继承了Thread类,就不能继承其他父类了,那就麻烦了~~
所以,在java中,少用继承(Thread),多用实现(Runnable接口)

Thread中的Run方法和start方法的区别:
Run方法只是普通方法调用,属于单线程运行程序
start方法 才是线程的正确启动方式,开启一个新的线程,不保证立即运行,由CPU调用

匿名对象: java中,如果一个对象只使用一次,可以使用匿名对象!
举个例子:
Student stu1 = new Student();
可以简写成:  new Student();

线程中怎么使用匿名: new Thread(new StartRun()).start();

Web12306 wb = new Web12306();   //  线程对象
new Thread(wb , "线程1").start();  // 给线程取个名字
new Thread(wb , "线程2").start();
new Thread(wb , "线程3").start();

//   获取这个线程的名字
System.out.println(Thread.currentThread().getName());   

线程方法:
sleep():让线程停止运行一段时间,处于阻塞状态,单位是时间(毫秒),sleep不会释放锁,抱着资源睡觉
join():阻塞指定的线程,等到另一个线程完成以后,再继续执行(可以理解为插队,让另一个线程优先执行)
yield():暂停当前线程,不是阻塞线程,而是将线程转入就绪状态,如果没有其他需要执行的线程,那么该线程就会马上执行(礼让)
stop():强行停止线程(不推荐使用)
setPoiroty(): 设置优先级, 0-10, 默认是5 , 优先级并不代表绝对的先后顺序,只是调整概率

线程阻塞哪几种情况:
sleep();
join();
wait();

sleep() 和 yield() 
sleep()是阻塞
yield()非阻塞


sleep()会自动唤醒(时间到了之后)
wait()需要自己手工调用notify()方法来唤醒

守护线程: 当被守护的线程执行完毕之后,守护线程也就会关闭

启动线程用 start()方法, 不是 Run()方法

这个教程还算可以
https://www.bilibili.com/video/av30023103/?p=199


静态代理:
https://www.bilibili.com/video/av30023103/?p=201



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

try  catch 里面try加入return
finally语句还是会执行,永远会被执行

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

时间复杂度和空间复杂度不可能同时解决

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

线程的生命周期:
1_新建状态 -> 2_就绪状态 -> 3_运行状态 -> 4_阻塞状态 -> 5_死亡状态


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

static 关键字:
1,随着类的加载而加载
2,被类的所有对象共享
3,如果某个成员变量被所有对象共享,那它应该被定义成静态的
4,可以通过类名.成员变量直接调用  Persion.name="jack"; 不用创建对象
5,静态元素只加载一次(只存在一份)

静态的成员方法不能访问非静态成员变量

静态方法没有this关键字,因为静态是随着类的加载而加载,this是随着对象的创建而存在

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

int占几个字节? 4个字节,32位
boolearn 1位 (true false)

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

为什么要有装箱和拆箱(Integer和int)??
因为java是一个面向对象的编程语言,而基本的数据类型,不具备面向对象的特性.基本数据类型不可以设置为null
举个例子:
Integer III = null;     不会报错    Integer类型可以为null
int iii = null;         报错,       int类型不能为null

假如,现在有个person类,用Integer直接判断是否为null; 但是int类型却不可以
Integer:包装类
int:基本数据类型


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


关于垃圾回收:
将无用的对象进行释放


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


Error 和 Exception 区别:
Error : jvm系统出错
Exception : 属于程序异常,可以用try...catch...捕获异常

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

fina : 定义常量, 方法, 类,声明的方法不能被覆写,声明的类不能被继承
finally: 异常的统一出口
finalaze:垃圾回收的收尾工作


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

assert???
java的一个关键字,开发中用的比较少

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

String sss = new String("AAA");
产生了两个实例化对象,一个是匿名对象"AAA",另一个是new实例化的

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

java没有goto这个关键字,属于保留关键字

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************
1, 重载 : 
        特点:
        方法名相同
        方法的参数类型，参数个不一样
        方法的返回类型 , 方法的修饰符 , 可以不相同
        *main 方法也可以被重载 
        
        构造方法可以被重载，但是构造方法不能被重写，子类也不能继承到父类的构造方法

如下所示:
    public static void AAA(){
        System.out.println("不传参数的时候,调用这个方法");
    }
    public static void AAA(int aaa){
        System.out.println("int aaa...........");
    }


2, 重写(又名覆写)
在继承的关系中,子类定义了和父类重名的方法,参数类型或者个数最好一样

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

set你的元素不能重复,那怎么区分是否重复呢??  用==还是 equals()?
答:用 equals() 进行比较,而==比较的是引用的地址,equals()比较的是内容

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


// 一个类只能继承一个抽象类,但是可以实现多个接口
抽象类:
    1,是个类,
    2,由抽象方法,常量,变量,构造方法,普通方法组成
    3,使用 abstract声明
    4,子类要通过 extends继承抽象类,子类如果不是抽象类,必须要覆写抽象类的全部抽象方法
    5,单继承,一个子类只能继承一个抽象类
    6,抽象类可以实现若干个接口
    6,抽象方法不能有方法体，即没有{}

    abstract不能修饰字段。既然是抽象方法，当然是没有实现的方法，根本就没有body部分

接口:
    1,使用 interface声明
    2,子类通过 implements实现接口,子类如果不是抽象类,必须要覆写抽象类的全部抽象方法
    3,不存在单继承局限,一个子类可以实现多个接口
    4,接口不能继承一个抽象类
    5,接口中所有的方法默认都是abstract的，所以接口可以使用abstract修饰，但通常 abstract 可以省略不写
    6,能够修饰interface的只有public、abstract以及默认的三种修饰符

abstract class Aaa{
    public void test(){
        System.out.println("Aaa.test");
    }
    public abstract void test2();
}
interface Bbb{
    public void test();
    public abstract void test2();
}

抽象类可以有方法体,也可以没有方法体
接口不能有方法体


// 实际开发中,接口使用频率 > 抽象类使用频率


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

设计模式:
    单例模式:
        特点:
            1,构造方法私有化


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

char 类型可以存放一个汉字

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

java两大数据类型:
1,基本数据类型
2,引用数据类型

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

三元运算符:
		boolean bb =  (1+1==2)?true:false;
		System.out.println(bb);


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

 String s1 = "QQ";
 String s2 = new String("QQ");

 System.out.println(s1 == s2);       // 返回 false
 System.out.println(s1.equals(s2));  // 返回 true       


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

实现字符串的反转:
        String s1 = "123-QWQ";
        StringBuffer stringBuffer = new StringBuffer(s1);
        System.out.println(stringBuffer.reverse().toString());


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

        Object[] arr = new Object[10];
        for (Object O : arr){
            System.out.println(O);
        }

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

遍历二维数组:
        for (String[] sss : s){
           for (String ssss : sss){
               System.out.println(ssss);
           }
        }

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

集合 迭代器 Iterator 以及 排序:
      List list=new ArrayList();
        list.add(1);
        list.add(6);
        list.add(3);

        System.out.println(list);
        Collections.sort(list);
        System.out.println(list);

        Iterator it =list.iterator();
        while (it.hasNext()){
            System.out.println(it.next());
        }

//       第二种遍历方式
        for (Object i : list){
            System.out.println(i);
        }


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************
java通过反射 拿到对象的属性:

package aaaaaaaa;
import java.lang.reflect.Field;
public class threadTest {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {

        Aaa aaaaa = new Aaa("Tom");
        Class clazz = aaaaa.getClass();
        Field ff = clazz.getDeclaredField("name");
        System.out.println(ff.isAccessible());

        ff.setAccessible(true);
        Object obj = ff.get(aaaaa);
        System.out.println(obj);
    }
}

class Aaa{
    private String name;
    public Aaa(String name) {
        this.name = name;
    }
    public String toString() {
        return "Aaa => [name=" + name + "]";
    }
}



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

链接数据库
        Class.forName("ccom.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection("url" , "username" , "password");
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery("sql");
        rs.next();

        rs.close();
        stmt.close();
        conn.close();

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

sql操作 事务 回滚
     Class.forName("ccom.mysql.jdbc.Driver");
        Connection conn = null;
        Statement stmt = null;

        try {
            conn  = DriverManager.getConnection("url" , "username" , "password");
            conn.setAutoCommit(false);  // 关闭自动提交
            stmt = conn.createStatement();
            stmt.executeUpdate("update user set name='123' where id=001");
            stmt.executeUpdate("update user set name='321' where id=002");
            conn.commit();    // 手动提交

        }catch (RuntimeException e){
            e.printStackTrace();
            if (conn != null){
                conn.rollback();   // 事务 回滚
            }
        }
        final{
            if (stmt != null){
                stmt.close();
            }
            if (conn != null){
                conn.close();
            }
        }

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

servlet 生命周期:
加载 -> 初始化 -> 提供服务 -> 销毁


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


如下四种情况时最容易造成内存泄露的场景，请大家开发时一定注意:
1> 创建大量无用对象
　　比如，我们在需要大量拼接字符串时，使用了String而不是StringBuilder
String str = "";
for (int i = 0; i < 10000; i++) {   
    str += i;     //相当于产生了10000个String对象
}


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

单例设计模式:
这个视频讲解的非常好
https://www.bilibili.com/video/av43222645/?p=33

1,私有的构造方法
2,私有的静态的当前类对象作为属性
3,公有的静态的方法返回当前类对象

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

final 修饰的值不可以被改变,不可以被重写,保证变量安全


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

class Teacher{
    public String name;

    // 成员内部类
    //      将一个类直接定义在类里面,作为成员,与属性或方法层一致
    //      可以和正常类一样,使用不同的修饰符来修饰
    //      可以访问外部类的所有成员,包括私有的
    //      调用 Teacher.Student sd = new Teacher().new Student();
    public class Student{
        public void aaa(){ // 内部类 的 方法
            System.out.println(Teacher.this.name);
        }
    }

    public void metherd(){
        //    局部内部类  第一种写法: 写在普通方法里面
        class clazz{
        }
    }

    {
        //    局部内部类 第二种写法: 写在静态static里面
        class clazz{
        }
    }

    public Teacher{
        //    局部内部类 第三种写法: 写在构造方法里面
        class clazz{
        }
    }
}


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

char不能使用双引号""  必须使用单引号''
        char ccc = '0'; 
        char bbb = "0";  //  编译报错

byte类型的数据,最大是127
        byte bb = 128;   // 报错

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件(.class文件)


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


什么是JVM? 什么是JDK? 什么是JRE?
简单来讲:
    JDK包含JRE，而JRE包含JVM

JDK,JRE,JVM三者关系概括如下:
        jdk是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE。
        JRE是JAVA程序运行时需要的运行环境，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了。
        JDk、JRE内部都包含JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。
    

JVM :
    JVM是Java Virtual Machine（Java虚拟机）的缩写，它是整个java实现跨平台的最核心的部分，
    所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，
    也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，
    由虚拟机将程序解释给本地系统执行。JVM是Java平台的基础，和实际的机器一样，它也有自己的指令集，
    并且在运行时操作不同的内存区域。 JVM通过抽象操作系统和CPU结构，提供了一种与平台无关的代码执行方法，
    即与特殊的实现方法、主机硬件、主机操作系统无关。
    JVM的主要工作是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰
    JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件（.class文件）

JRE: 
    JRE是java runtime environment（java运行环境）的缩写。光有JVM还不能让class文件执行，
    因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到jre目录，
    里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，
    而jvm和lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，
    这样你的朋友就可以运行你写程序了（jre里有运行.class的java.exe）。JRE是Sun公司发布的一个更大的系统，
    它里面就有一个JVM。JRE就与具体的CPU结构和操作系统有关，
    是运行Java程序必不可少的（除非用其他一些编译环境编译成.exe可执行文件……），JRE的地位就象一台PC机一样，
    我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行

JDK:
    JDK是java development kit（java开发工具包）的缩写。每个学java的人都会先在机器上装一个JDK，
    那让我们看一下JDK的安装目录。在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。
    其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、jre。现在我们可以看出这样一个关系，
    JDK包含JRE，而JRE包含JVM
                bin: 最主要的是编译器(javac.exe)
                include: java和JVM交互用的头文件
                lib：类库
                jre: java运行环境
（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）
    总的来说JDK是用于java程序的开发,而jre则是只能运行class而没有编译的功能。eclipse、idea等其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你选jre路径就ok了





*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

8种基本数据类型及其字节数  Java中的原生类（即基本数据类型）有8种，但不包括数组
整数型:      byte    (1字节)        4种
            short   (2字节)
            int     (4字节)
            long    (8字节)

浮点型:     float    (4字节)        2种
            double  (8字节)

布尔型:     boolean  (1位)          1种
字符型:     char     (2字节)        2种

PS:
        1：“字节”是byte，“位”是bit
        1 byte = 8 bit
        1 字节 = 8 位

        char 在Java中是2个字节。java采用 unicode ，2个字节（16位）来表示一个字符。
        short 2个字节
        int 4个字节
        long 8个字节 (64位)

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

&和&&的区别(不同点):
        对于&：无论任何情况，&两边的操作数或表达式都会参与计算
        对于&&：当&&左边的操作数为false或左边表达式结果为false时，&&右边的操作数或表达式将不参与计算，此时最终结果都为false。
        ** 推介平时多使用&&，因为它效率更高些

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

位运算符“<<”, 是将一个数左移n位，就相当于乘以了2的n次方，
那么，一个数乘以8只要将其左移3位即可，位运算cpu直接支持的，效率最高。
所以，2乘以8等于几的最效率的方法是2 << 3

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

break和continue的作用 区别
        break: 结束当前循环并退出当前循环体。
        break还可以退出switch语句
        continue: 循环体中后续的语句不执行，但是循环没有结束，继续进行循环条件的判断（for循环还会i++）。
                  continue只是结束本次循环。


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

递归算法解题通常显得很简洁，但运行效率较低。所以一般不提倡用递归算法设计程序

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

数组的长度是固定的，一经定义，不能再发生变化（数组的扩容）


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

this和super区别:

this是对象内部指代自身的引用,同时也是解决成员变量和局部变量同名问题；this可以调用成员变量，不能调用局部变量

super代表对当前对象的直接父类对象的引用，
super可以调用直接父类的成员变量
super可以调用直接父类的成员方法

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

static变量是属于整个类的，也称为类变量
 类名.变量名 直接调用

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

final和abstract 区别
abstract可以用来修饰类和方法，(不能用来修饰属性和构造方法)
抽象类:使用abstract修饰的类是抽象类，需要被继承，
抽象方法:使用abstract修饰的方法是抽象方法，需要子类被重写

final可以用来修饰类、方法和属性，不能修饰构造方法。
使用final修饰的类不能被继承，使用final修饰的方法不能被重写，
使用final修饰的变量的值不能被修改，所以就成了常量。

特别注意：final修饰基本类型变量，其值不能改变，由原来的变量变为常量；
但是final修饰引用类型变量，
栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。例如:
 
class Test {
    public static void main(String[] args) {
        final Dog dog = new Dog("欧欧");
        dog.name = "美美";//正确
        dog = new Dog("亚亚");//错误
    }
}



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

写出java.lang.Object类的六个常用方法:
                                1,equals      比较对象的地址值是否相等，如果子类重写，则比较对象的内容是否相等
                                2,hashCode()  获取哈希码
                                3,toString()  把数据转变成字符串
                                4,getClass()  获取类结构信息
                                5,notify()    多线程中唤醒功能
                                6,notifyAll() 多线程中唤醒所有等待线程的功能

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

区别:
public     公共的 可被同一项目中所有的类访问
default    默认的 可被同一个包中的类访问
protected  同一个类,同一个包,子类
private    私有的 只能被这个类本身访问


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

如果子类的构造方法中通过super显式调用父类的有参构造方法，那将执行父类相应构造方法，而不执行父类无参构造方法
如果子类的构造方法中没有通过super显式调用父类的有参构造方法，也没有通过this显式调用自身的其他构造方法，则系统会默认先调用父类的无参构造方法

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

==和equals的区别
“==”使用情况如下：
            a) 基本类型，比较的是值
            b) 引用类型，比较的是地址
            c) 不能比较没有父子关系的两个对象


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

垃圾回收:

public class threadTest {
    public static void main(String[] args) {
        Persion persion = new Persion();
        persion=null;
        System.gc();
    }

}

class Persion{
    public void finalize(){   // 重写垃圾回收的方法
        System.out.println("GC is return............");
    }
}




*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

Integer与int的区别 :
     int的默认值为0，而Integer的默认值为null，即Integer可以区分出未赋值和值为0的区别，int则无法表达出未赋值的情况，
     例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer
     在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为空白字符串，
     而int默认的默认值为0，所以用el表达式在文本框中显示时，结果为0，所以，int不适合作为web层的表单数据的类型

    int i1 = null;      // 报错
    Integer i2 = null;  // 不报错

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

 Java是解释型语言，编译出来的是字节码 Java程序经编译后会生产byte code

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

static方法能处理非static的属性 是错误的!!
分析：因为static得方法在装载class得时候首先完成，比构造方法早，此时非static得属性和方法还没有完成初始化所以不能调用

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

面向对象的三大特征：封装、继承、多态

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

如何看见 java.lang.OutOfMemoryError (内存溢出 内存泄漏) ?
在eclipse运行下面这段代码,并且 在eclipse运行参数中, Run Configuration->VM argument设置:-Xmx5m -Xmx5m
        int count = 0;
        List<Object> list = new ArrayList<Object>();
        while(true){
            list.add(new Object());
            System.out.println(++count);
        }

详情见:
https://www.cnblogs.com/xiaoxi/p/7406903.html        
		
	

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

        int aaa = 1;
        int bbb = 1;
        System.out.println(aaa++); // 输出: 1 (先输出,再去+1)
        System.out.println(++bbb); // 输出: 2 (先+1 , 再输出)

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

Java 中byte表示的数值范围是什么?  
答： 范围是-128至127

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************



java程序经编译后会产生 byte code (字节码文件)

分析：java程序编译后会生成字节码文件,就是.class文件



*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


成员变量用static修饰和不用static修饰有什么区别?

1，两个变量的生命周期不同
        成员变量随着对象的创建而存在，随着对象的被回收而释放
        静态变量随着类的加载而存在，随着类的消失而消失

2，调用方式不同。
        成员变量只能被对象调用。
        静态变量可以被对象调用，还可以被类名调用

        对象调用：p.country
        类名调用 ：Person.country

3，别名不同
        成员变量也称为实例变量
        静态变量称为类变量

4，数据存储位置不同
        成员变量数据存储在堆内存的对象中，所以也叫对象的特有数据.
        静态变量数据存储在方法区(共享数据区)的静态区，所以也叫对象的共享数据


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

如果变量用final修饰，则怎样？如果方法final修饰，则怎样?

1、用final修饰的类不能被扩展，也就是说不可能有子类
3、用final修饰的变量最多只能赋值一次

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

        Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;
        System.out.println(f1 == f2);   // 返回 true
        System.out.println(f3 == f4);   // 返回 false

        咦?? 很奇怪吧?? 如果不明就里很容易认为两个输出要么都是true要么都是false
         
        首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象，所以下面的==运算比较的不是值而是引用

        简单的说，如果字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，
        所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


很多时候我们可能都需要用&&而不是&，
例如在验证用户登录时判定用户名不是null而且不是空字符串，
应当写为：
username != null && !username.equals("")
二者的顺序不能交换，
更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************

switch表达式后面的数据类型只能是byte,short，char，int四种整形类型，
枚举类型和java.lang.String类型（从java 7才允许），
不能是boolean类型。

总结: 6种类型: 
            byte,short,char,int四种整形类型  加上: 枚举类型(enum) , String 
            总共6种

在网上看到好多文章，说switch还支持byte,short,char,int 的包装类，
首先可以肯定说switch不支持这些包装类

*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************


*******************************************************************************************
*******************************************************************************************
*******************************************************************************************






















































































































Compile:编绎

Run:运行

Class:类

Object:对象

System:系统

System:系统

out:输出

print:打印

line:行

variable:变量

type:类型

static:静态的

array:数组

parameter:参数

method:方法

function:函数

public:公有的

default:默认

get:得到

private:私有的

import:导入

set:设置

package:包

access:访问
atement:表行对象

 

protected:受保护的

 

void:无(返回类型)

 

operation:操作,运算

 

member-variable:成员变量

 

member-function:成员函数

 

extends:继承

 

base

 

class:基类

 

parent

 

class:父类

 

interface:接口

 

child

 

class:子类

 

super

 

class:超类

 

overload:重载

 

abstract:抽象

 

exception:异常

 

implements:实现

 

Runtime:运行时

 

derived

 

class:派生类

 

override:重写,覆盖

 

final:最终的,不能改变的

 

ArrayIndexOutOfBoundsException:数组下标越界异常

 

ArithmeticException:算术异常

 

NullPointerException:空引用(指针)异常

 

ClassNotFoundException:类没有发现异常

 

NumberFormatException:数字格式异常(字符串不能转化为数字)

 

Try:尝试

 

Catch:捕捉

 

Finally:最后

 

Throw:抛出

 

Throws:

 

(投掷)表示强制异常处理

 

Throwable:(可抛出的)表示所有异常类的祖先类

 

Lang:language,语言

 

Random:随机

 

Util:工具

 

Display:显示

 

Collection:集合

 

ArrayList:(数组列表)表示动态数组

 

HashMap:

 

散列表,哈希表

 

Swing:轻巧的

 

Awt:abstract

 

window

 

toolkit:抽象窗口工具包

 

Frame:窗体

 

Size:尺寸

 

Title:标题

 

Add:添加

 

Panel:面板

 

Layout:布局

 

Scroll:滚动

 

Vertical:垂直

 

Horizonatal:水平

 

Label:标签

 

TextField:文本框

 

TextArea:文本域

 

Button:按钮

 

Checkbox:复选框

 

Focus:焦点

 

Event:事件

 

Combobox:复选框

 

Listener:监听

 

Mouse:鼠标

 

Key:键

 

Grid:网格

 

Border:边界

 

Flow:流

 

MenuItem:菜单

 

项

 

MenuBar:菜单栏

 

Menu:菜单

 

Icon:图标

 

Dialog:对话框

 

Message:消息

 

Tree:树

 

Node:节点

 

Radiobutton:单选按钮

 

PopupMenu:弹出菜单

 

Jdbc:java

 

database

connectivity,java

数据库连接
--------------------- 
作者：身轻如阿宝 
来源：CSDN 
原文：https://blog.csdn.net/gt674342815/article/details/77826097 
版权声明：本文为博主原创文章，转载请附上博文链接！